import torch
from flow_matching.solver import ODESolver

straightness_simulation_steps = 200


class Metrics:
    @staticmethod
    def calculate_path_straightness(model, x0: torch.Tensor) -> torch.Tensor:
        """
        Computes path straightness

        S = E_{t, q0(x0)}[||u_t(psi_t(x0))||^2 - ||psi_1(x0)-x0||^2]

        where psi_t is generated by solving d psi_t / dt = u_t(psi_t).

        Args:
            model: Velocity model u_t(x).
            x0 (torch.Tensor): Batch of start points in R^d (or any tensor-valued state space), shape [N, ...].

        Returns:
            torch.Tensor: Scalar tensor containing S.
        """
        if x0.ndim < 2:
            raise ValueError(f"Expected x0 with shape [N, ...], got {tuple(x0.shape)}")

        model_device = next(model.parameters()).device
        x0 = x0.to(model_device)

        solver = ODESolver(velocity_model=model)
        time_grid = torch.linspace(
            0.0,
            1.0,
            steps=straightness_simulation_steps,
            device=model_device,
            dtype=x0.dtype,
        )

        was_training = model.training
        model.eval()
        with torch.no_grad():
            trajectories = solver.sample(
                x_init=x0,
                method="midpoint",
                step_size=1.0 / straightness_simulation_steps,
                return_intermediates=True,
                time_grid=time_grid,
            )

            if isinstance(trajectories, torch.Tensor):
                trajectory_sequence = [trajectories[t_idx] for t_idx in range(trajectories.shape[0])]
            else:
                trajectory_sequence = list(trajectories)

            velocity_norm_sq_values = []
            for t_value, psi_t in zip(time_grid, trajectory_sequence):
                t_batch = torch.full(
                    (psi_t.shape[0],),
                    fill_value=t_value.item(),
                    device=psi_t.device,
                    dtype=psi_t.dtype,
                )
                velocity_t = model(psi_t, t_batch)
                velocity_norm_sq = velocity_t.reshape(velocity_t.shape[0], -1).pow(2).sum(dim=1)
                velocity_norm_sq_values.append(velocity_norm_sq)

            mean_velocity_norm_sq = torch.stack(velocity_norm_sq_values, dim=0).mean(dim=0)
            psi_1 = trajectory_sequence[-1]
            displacement_norm_sq = (psi_1 - x0).reshape(x0.shape[0], -1).pow(2).sum(dim=1)
            straightness = (mean_velocity_norm_sq - displacement_norm_sq).mean()

        if was_training:
            model.train()

        return straightness
