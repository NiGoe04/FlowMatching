import torch
from flow_matching.solver import ODESolver

from src.flow_matching.model.coupling import Coupler
from src.flow_matching.model.losses import TensorCost

straightness_simulation_steps = 256


class Metrics:
    @staticmethod
    def _calculate_mean_velocity_norm_sq(model, x0: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:
        """
        Approximates path energy PE(v_theta) using Monte Carlo averaging over time samples.

        PE(v_theta) = E_{x0 ~ q0} \int_0^1 ||v_theta(t, x(t))||^2 dt

        The time integral is approximated by a discrete average over `straightness_simulation_steps`.

        Returns:
            tuple[torch.Tensor, torch.Tensor]:
                - mean velocity norm squared per sample (discrete-time MC estimate of PE)
                - final state psi_1 for each sample
        """
        if x0.ndim < 2:
            raise ValueError(f"Expected x0 with shape [N, ...], got {tuple(x0.shape)}")

        model_device = next(model.parameters()).device
        x0 = x0.to(model_device)

        solver = ODESolver(velocity_model=model)
        time_grid = torch.linspace(
            0.0,
            1.0,
            steps=straightness_simulation_steps,
            device=model_device,
            dtype=x0.dtype,
        )

        with torch.no_grad():
            trajectories = solver.sample(
                x_init=x0,
                method="midpoint",
                step_size=1.0 / straightness_simulation_steps,
                return_intermediates=True,
                time_grid=time_grid,
            )

            if isinstance(trajectories, torch.Tensor):
                trajectory_sequence = [trajectories[t_idx] for t_idx in range(trajectories.shape[0])]
            else:
                trajectory_sequence = list(trajectories)

            velocity_norm_sq_values = []
            for t_value, psi_t in zip(time_grid, trajectory_sequence):
                t_batch = torch.full(
                    (psi_t.shape[0],),
                    fill_value=t_value.item(),
                    device=psi_t.device,
                    dtype=psi_t.dtype,
                )
                velocity_t = model(psi_t, t_batch)
                velocity_norm_sq = velocity_t.reshape(velocity_t.shape[0], -1).pow(2).sum(dim=1)
                velocity_norm_sq_values.append(velocity_norm_sq)

            mean_velocity_norm_sq = torch.stack(velocity_norm_sq_values, dim=0).mean(dim=0)
            psi_1 = trajectory_sequence[-1]

        return mean_velocity_norm_sq, psi_1

    @staticmethod
    def calculate_path_straightness(model, x0: torch.Tensor) -> torch.Tensor:
        """
        Computes path straightness

        S = E_{t, q0(x0)}[||u_t(psi_t(x0))||^2 - ||psi_1(x0)-x0||^2]

        where psi_t is generated by solving d psi_t / dt = u_t(psi_t).

        Args:
            model: Velocity model u_t(x).
            x0 (torch.Tensor): Batch of start points in R^d (or any tensor-valued state space), shape [N, ...].

        Returns:
            torch.Tensor: Scalar tensor containing S.
        """
        model_device = next(model.parameters()).device
        x0 = x0.to(model_device)

        was_training = model.training
        model.eval()
        with torch.no_grad():
            mean_velocity_norm_sq, psi_1 = Metrics._calculate_mean_velocity_norm_sq(model, x0)
            displacement_norm_sq = (psi_1 - x0).reshape(x0.shape[0], -1).pow(2).sum(dim=1)
            straightness = (mean_velocity_norm_sq - displacement_norm_sq).mean()

        if was_training:
            model.train()

        return straightness

    @staticmethod
    def calculate_normalized_path_energy(model, x0: torch.Tensor, x1: torch.Tensor) -> torch.Tensor:
        """
        Computes normalized path energy:

        NPE(v_theta) = |PE(v_theta) - W2^2(q0, q1)| / W2^2(q0, q1)

        where PE(v_theta) is approximated by Monte Carlo averaging over discrete time samples.
        """
        model_device = next(model.parameters()).device
        x0 = x0.to(model_device)
        x1 = x1.to(model_device)

        was_training = model.training
        model.eval()
        with torch.no_grad():
            mean_velocity_norm_sq, _ = Metrics._calculate_mean_velocity_norm_sq(model, x0)
            path_energy = mean_velocity_norm_sq.mean()

            coupler = Coupler(x0, x1)
            ot_coupling = coupler.get_n_ot_coupling(n=len(x0), cost_fn=TensorCost.quadratic_cost)
            w2_sq = TensorCost.quadratic_cost(ot_coupling.x0, ot_coupling.x1).diagonal().mean()
            normalized_path_energy = (path_energy - w2_sq).abs() / w2_sq

        if was_training:
            model.train()

        return normalized_path_energy
